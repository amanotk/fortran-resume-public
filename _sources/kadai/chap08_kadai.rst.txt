.. -*- coding: utf-8 -*-

第8章 演習課題
==============

  `課題PDFダウンロード <chap08_kadai.pdf>`_

課題1
-----

サンプルプログラムをコンパイル・実行して動作を確認せよ．さらに，適宜修正してその実行結果を確認せよ．


課題2
-----

2次方程式 :math:`a x^2 + b x + c = 0`
の解は以下の解の公式を用いて求めることが出来る．

.. math::

  x = \frac{-b \pm \sqrt{b^2 - 4 a c}}{2 a}

しかしこの公式を単純に用いた場合には :math:`b^2 \gg 4 a c` の時には，桁落ちによってどちらか一方の解の精度が悪くなってしまう．このことを実際に確認し，式変形によってその精度を改善せよ．

例えば :math:`a = 1, b = -10^{9}, c = 1` とした時の解は

.. math::

  x \simeq 1.\underbrace{000000000000000}_{0が15個} \times 10^{9}, \quad
  1.\underbrace{000000000000000}_{0が15個} \times 10^{-9}

であるが，解の公式を用いた場合と式変形によって桁落ち対策をした場合で数値解を比較せよ．(桁落ち対策が必要なのはどちらか一方の解のみである．)


課題3
-----

Newton法では関数の微分値を解析的に与えて用いるが，割線法(Secant method)と呼ばれる手法では連続した2つの近似解を用いて，微分を差分で近似する．即ち :math:`n` 番目の近似解を :math:`x_n` と書いたときに，Newton法の公式

.. math::

  x_{n+1} = x_{n} - \frac{f(x_{n})}{f'(x_{n})}

において，微分値を以下のように近似する．

.. math::

  f'(x_n) \simeq \frac{f(x_{n}) - f(x_{n-1})}{x_{n} - x_{n-1}}

(この手法では微分値の計算をする必要がないため，反復1回あたりの計算量が少なくなる可能性があるが，収束はNewton法よりも少し遅くなる．)

この割線法を実装し，以下の方程式

.. math::

  f(x) = \frac{1-x}{\sqrt{M}} - \exp(x)

を数値的に解くことで，その収束の速さを二分法およびNewton法と比較せよ．ただし :math:`M= 1836` とする．なお解は :math:`x \simeq -2.5` なので二分法ではこの前後に2つの初期値を指定すればよい．割線法も2つ初期値が必要になるが，(この関数に関しては)初期値には敏感ではないので，例えば0と1を初期値として用いればよい．ここでは収束の速さを比較すればよいので，各反復ごとの収束判定はせずに20回程度の反復を行い誤差の減少の様子をgnuplotを用いて図示せよ．ただし連続する2つの近似解の差を誤差と定義する．

結果は以下の例ようになるであろう．

.. figure:: figure/rootfind.png
  :align: center
  :width: 75%

  求根法の収束比較

課題4
-----

:math:`f(x) = \dfrac{4}{\pi} \dfrac{1}{1 + x^2}` および :math:`f(x) = (n+1) \ x^{n} \ (n = 0, \ldots, 5)` のそれぞれについて

.. math::

  \int_{0}^{1} f(x) dx

の積分を台形公式およびSimpsonの公式で数値的に行い，誤差の分割数に対する依存性をgnuplotを用いて図示せよ．例えば分割数を :math:`2^{n} (n=1, 2, \ldots, 16)` の範囲で変えて依存性を調べれば良い．

例として :math:`f(x) = \dfrac{4}{\pi} \dfrac{1}{1 + x^2}` について誤差をプロットすると以下のようになるであろう．

.. figure:: figure/integration.png
  :align: center
  :width: 75%

  数値積分誤差の分割数依存性

このような依存性となる理由を考えよう．


課題5
-----

一様乱数を用いてある確率分布に従う乱数を発生させるために逆関数を用いる方法(変換法や逆関数法などと呼ばれる)を考える．区間 :math:`[0, 1)` での一様乱数 :math:`x` およびその確率分布 :math:`f(x)` ，また必要な乱数 :math:`y` とその確率分布 :math:`g(y)` とする．ただし乱数の値域は :math:`a \leq y < b` とする． :math:`y` を :math:`x` から何らかの変換で :math:`y = P(x)` のように表すとき，確率密度の保存から

.. math::

    g(y) d y = f(x) dx = d x

が成り立つ．(最後の等式は一様乱数であることから自明である．)
この両辺を積分して

.. math::

  x = \frac
  { \int^{y}_{a} g(y') d y' }
  { \int^{b}_{a} g(y') d y' }
  \equiv G(y)

によって関数 :math:`G(y)` を定義する．ただし :math:`G(a) = 0` ， :math:`G(b) = 1` となるように規格化した．これより

.. math::

  y = G^{-1} (x)

を得る．即ち， :math:`G^{-1} (x)` を解析的に求めることができれば，一様乱数 :math:`x` を用いて必要な確率分布 :math:`g(y)` に従う乱数を作ることができる．（以下の図を参照）

.. figure:: figure/inversefunc.png
  :align: center
  :width: 480px

  逆関数法の概念図

このことを用いて指数分布

.. math::

    g(y; \lambda) = \lambda \exp(-\lambda y)

に従う乱数分布を発生させるプログラムを作成せよ．また分布のヒストグラムを作成し，gnuplotを用いてヒストグラムを解析的な分布と共に図示し，乱数の発生数を増やした時に乱数分布が真の分布に近づくことを確かめよ．

以下は60000個の乱数を発生させた場合のヒストグラムの例である．

.. figure:: figure/expdist.png
  :align: center
  :width: 480px

  指数分布のヒストグラム


課題6 :sup:`†`
---------------

乱数を利用した数値積分法としてモンテカルロ法が知られている．これを用いて :math:`n` 次元ユークリッド空間における単位超球の体積 :math:`V_n` を求めるプログラムを作成せよ．

ただし :math:`n` 次元超球の体積は :math:`n` 次元空間の座標を :math:`x_i \, (i=1, \ldots, n)` とし，

.. math::

  \sum_{i=1}^{n} x_i^{2} \leq 1

なる領域の体積と定義される．ここで対称性から :math:`0 \leq x_i \leq 1` の領域のみを考えれば，この体積は :math:`V_n / 2^{n}` となる．従って :math:`n` 個の一様乱数 :math:`0 \leq x_i < 1 \, (i=1, \ldots, n)` を発生させ，上式の条件を満足するかどうかを調べる試行を多数回行い，その確率を求めることによって :math:`V_n / 2^{n}` を推定すればよい．

なお真の値は

.. math::

  V_n = \frac{ \pi^{n/2} }{ \Gamma(n/2 + 1) }

によって与えられる．

例えば次元数と試行回数を標準入力から与える形式のプログラムの実行結果は以下のようになる．この例のように誤差は試行回数 :math:`m` に対して， :math:`1/\sqrt{m}` に比例して減少する．

.. code-block:: bash

  $ ./a.out
  2 1000    # キーボード入力(2次元，試行回数1000回)
  approximation  =       0.32240000E+01
  exact value    =       0.31415927E+01
  relative error =       0.26231044E-01
  $ ./a.out
  2 100000  # キーボード入力(2次元，試行回数100000回)
  approximation  =       0.31430400E+01
  exact value    =       0.31415927E+01
  relative error =       0.46067683E-03
