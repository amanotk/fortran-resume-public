.. -*- coding: utf-8 -*-

.. highlight:: fortran
  :linenothreshold: 1

====
付録
====

.. seealso::

    - :doc:`sample1.f90 <chap10_sample1_f90>` : 分割コンパイル用サンプル
    - :doc:`sample1a.f90 <chap10_sample1a_f90>` : 分割コンパイル用サンプル(モジュールA)
    - :doc:`sample1b.f90 <chap10_sample1b_f90>` : 分割コンパイル用サンプル(モジュールB)
    - :doc:`sample2.f90 <chap10_sample2_f90>` : GUIライブラリの使い方
    - :doc:`sample3.f90 <chap10_sample3_f90>` : 二分法モジュール(mod_bisection)の使い方
    - :doc:`bisection.f90 <chap10_bisection_f90>` : 二分法モジュール(mod_bisection)の実装
    - :doc:`sample4.f90 <chap10_sample4_f90>` : 計算時間の測定
    - :doc:`sample5.f90 <chap10_sample5_f90>` : ポインタの使い方
    - :doc:`sample6.f90 <chap10_sample6_f90>` : リストモジュール(mod_list)の使い方
    - :doc:`list.f90 <chap10_list_f90>` : リストモジュール(mod_list)の実装
    - :doc:`sample7.f90 <chap10_sample7_f90>` : プリプロセッサの使い方

.. contents:: この章の内容
    :depth: 2

大規模なプログラム開発
======================

分割コンパイル
--------------

これまでは基本的に単一のソースファイルからなるプログラムを扱ってきたが，大規模なプログラムを扱う際にはソースファイルをいくつかに分割して扱うと開発の見通しが良くなる．複数のソースファイルからなるプログラムを開発するにあたって，まずは単一のソースファイルから実行形式のファイルを作る手順を復習しよう．

これまでは例えば

.. code-block:: bash

     $ gfortran sample.f90

によってソースファイルから実行ファイル ``a.out`` を作成してきた．これは実際には **コンパイル** と **リンク** という2つのステップを同時に行うものである．

コンパイルとはソースファイルを解釈し，機械語に変換する作業である．機械語に変換されたファイルを **オブジェクトファイル** と呼び，通常は拡張子 ``.o`` が用いられる．オブジェクトファイルを生成するには

.. code-block:: bash

     $ gfortran -c sample.f90

のように ``-c`` オプションを付けてコンパイルする．この結果，この例では ``sample.o`` が生成される．生成されたオブジェクトファイルは機械語になってはいても，実際にプログラムを実行可能な形式にはなっておらず，関数やサブルーチンなどの単位で個別に機械語になっているだけである．実行形式に変換するには，それらの自分で実装したものに加え，組み込み関数( ``read`` ，``write`` なども実際には組み込み関数の1種である)などを連結する作業が必要である．組み込み関数などのまとまりを標準ライブラリと呼び，この連結作業をリンクと呼ぶ．

オブジェクトファイルをリンクするには

.. code-block:: bash

     $ gfortran sample.o

とすればよい．この例では ``sample.o`` と標準ライブラリがリンクされ，実行可能なファイル(この例では ``a.out`` )が生成される．

次に複数のファイルからなるプログラムの場合を考えよう．例えばメインプログラムが定義されている ``sample1.f90`` が ``sample1a.f90`` に，また ``sample1a.f90`` が ``sample1b.f90`` に依存している場合には

.. code-block:: bash

     $ gfortran sample1b.f90 sample1a.f90 sample1.f90

のようにすれば，コンパイルとリンクを1つのコマンドで同時に実行することができる(順番に注意)．これは実際には以下のように各ファイルを個別にコンパイルし，最後に全体をリンクする作業に相当する．

.. code-block:: bash

     $ gfortran -c sample1b.f90
     $ gfortran -c sample1a.f90
     $ gfortran -c sample1.f90
     $ gfortran sample1b.o sample1a.o sample1.o

リンク時には与えられた全てのオブジェクトファイルに加えて，常に標準ライブラリがリンクされる．

このように分割コンパイルを用いる利点は，コンパイル時間の短縮にある．個別にコンパイルが出来るので，ソースファイルを更新した場合には，その必要なファイルだけを再コンパイルすれば良い．なお，リンクにかかる時間は通常短く，コンパイル時間に対しては無視できる．従って，頻繁に修正をしながらテストする場合などでは，実行ファイルの作成にかかる時間を短縮できることになる．

なお，Fortranでモジュールを用いる場合は ``gfortran -c`` によるコンパイルで ``.mod`` という拡張子のファイル(例えばモジュール名が ``test`` なら ``test.mod`` )が生成される．別ファイルのモジュールを利用する際には，この ``.mod`` ファイルが無いとコンパイル出来ないので注意しよう [#]_．また他のディレクトリに ``.mod`` ファイルがある場合には，``-I`` オプションを用いてコンパイラが ``.mod`` ファイルを探す場所を指定することが出来る [#]_．

.. code-block:: bash

     $ gfortran -c -I../module sample.f90

のように実行すれば，カレントディレクトリに加えて ``../module`` にある ``.mod`` ファイルも参照することになる．規模が大きなプログラムではいくつかのディレクトリにファイルを分散して配置するようになるため，``-I`` オプションを頻繁に用いることになるだろう．

ライブラリの利用方法
--------------------

一般に，関数やサブルーチン群をひとまとまりにしたものをライブラリと呼ぶ．これまでにも組み込み関数などの標準で用意されている便利な機能を利用してきたが，これは標準ライブラリが提供するものである．これと同じように，他の誰かが開発した便利な関数やサブルーチンを自分のプログラムから呼び出して利用することも出来る．

ライブラリは通常(Unix系のOSでは) ``libABC.a`` や ``libXYZ.so`` といったファイル名になっている(これらをアーカイブとも呼ぶ)．基本的には実行形式のファイルを作成するリンク時にこれらのライブラリともリンクするように指定してやれば良い．例えば

.. code-block:: bash

     $ gfortran main.o -lABC -lXYZ

とすれば ``libABC.a``，``libXYZ.so`` の両方とリンクすることが出来る．このようにライブラリとリンクするには，拡張子とファイル先頭の ``lib`` を除いたライブラリ名を ``-l`` オプションに渡せば良い．ただし，ライブラリファイルがあるディレクトリがカレントディレクトリや標準の場所(通常 ``/usr/lib`` や ``/usr/local/lib`` など)以外の場合にはその場所を ``-L`` オプションで明示的に指定してやらなければならない．以下の例では ``libABC.a`` が ``../lib`` にあるの場合に，それを明示的に指定してリンクを実行する．

.. code-block:: bash

     $ gfortran main.o -L../lib -lABC

GUIプログラムの作成 :sup:`†`
-----------------------------

.. raw:: html

   <!--
   数値計算関係のライブラリはこれからも多々使う機会があると思うので，ここではちょっと違った例としてGUI(Graphical User Interface)のライブラリを使ってみよう．GUIのライブラリは様々なものが存在するが，ここではFortranから使えるGTK+を用いる．サンプルプログラム`samle2.f90`をコンパイルするには

   ```{style=shell}
    $ gfortran sample2.f90 `pkg-config --cflags --libs gtk-2-fortran`
   ```

   のようにすれば良い．
   -->

Makeの使い方
------------

To be written.

関数やサブルーチンの引数渡し
============================

関数やサブルーチンの引数として，関数やサブルーチンを渡すことが出来る．これには以下のように引数として渡す関数やサブルーチンの形式を ``interface`` を用いて指定する．

.. code-block:: fortran

      subroutine writefunc(f, x)
        implicit none
        real(8), intent(in) :: x

        ! 引数として受け取る関数の形式
        interface
           function f(x) result(y)
             real(8), intent(in) :: x
             real(8) :: y
           end function f
        end interface

        write(*,'("f(", e12.5, ") = ",  e12.5)') x, f(x)

      end subroutine writefunc

より実用的な例として二分法のアルゴリズムを実装した以下の様なモジュール(抜粋)を考えよう．``bisection`` というサブルーチンは関数 :math:`f(x)` を引数として受け取り，:math:`f(x) = 0` の解を求める．このようなモジュールを定義しておけば，:math:`f(x)` の具体的な形が変わってもメインプログラムで ``bisection`` の引数として渡す関数を変更するだけで良い．このように，汎用性の高いモジュールを作成しておくことで再利用が非常に簡単になる．

なお，このサブルーチンでは最大の反復回数や許容誤差は ``optional`` 属性の引数となっていることにも着目して欲しい．これらが与えられない場合にはモジュール内で定義されたデフォルトの値を用いるようになっている．

.. code-block:: fortran

    module mod_bisection
      implicit none
      private

      integer, parameter :: default_maxit = 50
      real(8), parameter :: default_tol   = 1.0e-8_8

      public :: bisection

    contains
      ! 二分法により与えられた方程式の解を求める
      subroutine bisection(f, x1, x2, error, status, maxit, tol)
        implicit none
        real(8), intent(inout) :: x1, x2
        real(8), intent(out) :: error
        integer, intent(out) :: status
        integer, intent(in), optional :: maxit
        real(8), intent(in), optional :: tol
        ! 引数として関数を受け取る
        interface
           function f(x) result(y)
             real(8), intent(in) :: x
             real(8) :: y
           end function f
        end interface

        integer :: i, n
        real(8) :: x, y, sig, tolerance

        ! 最大の反復回数
        if (.not. present(maxit)) then
           n = default_maxit
        else
           n = maxit
        end if

        ! 許容誤差
        if (.not. present(tol)) then
           tolerance = default_tol
        else
           tolerance = tol
        end if

        !
        ! 以下略
        !

      end subroutine bisection

    end module mod_bisection

なお ``bisection.f90`` で上記モジュールが定義されており，``sample3.f90`` がこれを用いるメインプログラムである．これをコンパイルするには

.. code-block:: bash

     $ gfortran -c bisection.f90
     $ gfortran -c sample3.f90
     $ gfortran sample3.o bisection.o

もしくは

.. code-block:: bash

     $ gfortran bisection.f90 sample3.f90

とすれば良い．

計算時間の測定
==============

プログラム全体の実行時間はシェルコマンドで計測できる．例えば ``time`` コマンドを用いて以下のように実行すれば良い [#]_．realの行が実際の実行時間を示している．大雑把には全実行時間のうち，userが自分のプログラムの処理が動いていた時間，sysはOSの処理が動いていた時間を表す．

.. code-block:: bash

     $ /usr/bin/time ./a.out
            0.98 real         0.97 user         0.00 sys

アルゴリズムによる実効速度の違いを検証したり，プログラムのチューニングをするようになってくると，プログラムのある特定の部分の実行時間を測定する必要が出てくる．ここでは ``cpu_time`` という組込みサブルーチンを使った時間計測のサンプルプログラムを以下に示す．

.. code-boock:: fortran

    program sample
      implicit none

      integer :: i
      real(8) :: x, y, pi, t1, t2

      call cpu_time(t1)

      do i = 1, 20000000
         pi = 4.0_8 * atan(1.0_8)
         y  = cos(2*pi*x)
         x  = y
      end do

      call cpu_time(t2)

      write(*,'("CPU Time [sec] : ", e12.4)') t2 - t1

      stop
    end program sample

実行結果は以下のようになる．

.. code-block:: bash

     $ ./a.out
     CPU Time [sec] :   0.8601E+00

サンプルプログラムでは9-12行目の処理にかかる時間を計測している．``cpu_time`` の呼び出しによって引数に現在の時刻が秒単位で代入されるので，計測したい部分の前後でこの値の差をとればよい．ただし正確に計算時間を計測する際には以下のようにいくつか注意が必要である．

-  ``write`` や ``read`` のようなI/O(入出力)は避ける.これらは非常に時間のかかる処理であるので，入出力があると純粋な計算時間を正確に測ることが出来ない．
-  計測対象がある程度時間のかかる処理(例えば :math:`\gtrsim 1` 秒)であること．``cpu_time`` の返す時刻の精度は :math:`1 \mu s` 程度である．
-  何度か同じ計測をしてばらつきを見ること．現在のほぼ全ての計算機はマルチタスクOSであり，多くの処理を同時に行なっているため，ユーザーが実行しているプログラムの処理に全てのリソースが使われるわけではない．たまたま他のプログラムが走っているタイミングで実行された場合にはパフォーマンスがでない可能性がある．

なお，細かいことを言うと経過時間(elapsed time)，CPU時間(cpu time)，システムCPU時間(system cpu time)，ユーザーCPU時間(user cpu time)で意味が少しずつ異なることに注意しよう．``cpu_time`` で計測されるのはCPU時間である．

ポインタとデータ構造 :sup:`†`
==============================

ポインタとは簡単に言えば別名である．即ち，ポインタ変数は他の変数や配列によって保持されているデータ領域のメモリ上のアドレス(番地)を指し示す変数になっている．例えば，ポインタ変数に対する処理として記述しておけば，ポインタ変数の指し示すアドレスを変更するだけで異なるデータに対する処理を行っていることになる．

しかし，ポインタはこれまで出てきたような処理には敢えて用いる必要が無いので，あまりありがたみを感じられないかもしれない．実際にはポインタはリストやスタック，キューなどのより複雑な :ref:`appendix_data_structure` を記述するには必須であるが，そうでなければ必ずしも必要にはならない．ポインタは初心者には少し難しいかもしれないので，分からなければとりあえずは無視しても良い．

ポインタ変数
------------

ポインタを用いるには変数宣言に ``pointer`` 属性を指定すれば良い．またポインタが指し指すことの出来る変数(ターゲット変数)には ``target`` 属性を指定する必要がある．以下の例を考えよう．

.. code-block:: fortran

      integer, pointer :: iptr
      integer, target  :: i, j

      i = 5
      j = 9

      ! 出力は iptr = 5, i = 5, j = 9
      iptr => i
      write(*,'(" iptr = ", i3, ", i = ", i3, ", j = ", i3)') iptr, i, j

      ! 出力は iptr = 9, i = 5, j = 9
      iptr => j
      write(*,'(" iptr = ", i3, ", i = ", i3, ", j = ", i3)') iptr, i, j

      ! 出力は iptr = 0, i = 5, j = 0
      iptr = 0
      write(*,'(" iptr = ", i3, ", i = ", i3, " j, = ", i3)') iptr, i, j

8行目の ``iptr => i`` によって ``iptr`` は ``i`` のアドレスを指すことになる( ``iptr`` が ``i`` の別名となる)ので，9行目の出力では"iptr = 5, i = 5, j = 9"となる．同様に12行目の ``iptr => j`` によって ``iptr`` は ``j`` のアドレスを指すことになる．また，16行目の ``iptr = 0`` は ``iptr`` の指すアドレスへの代入なので，この結果 ``iptr`` だけでなく ``j`` の値も変更されることになる．この代入文のように，ポインタ変数に対しても通常の変数のように任意の演算が可能である [#]_．

なお ``nullify`` によってポインタ変数とターゲット変数との結合を解除することが出来る．またポインタは **無名領域** (他の変数によって指し示されていない領域)との結合も可能である．これは動的配列の場合と同様に ``allocate`` によって行い，この場合の結合の解除は( ``nullify`` では無く) ``deallocate`` によって行う．また，結合状態を検査するための組込み関数 ``associated`` も用意されている．この関数はポインタが結合状態であれば真，そうでなければ偽を返す．従って例えば以下のように使うことが出来る．

.. code-block:: fortran

      if( associated(iptr) ) then
        nullify(iptr)
      end if

      allocate(iptr)
      iptr = 1

      deallocate(iptr)

ポインタ配列
------------

ポインタ配列はターゲット配列と結合させることが出来る．ただし両者の次元は同じでなければならない．ポインタ配列は配列全体を指したり，部分配列を指したりすることが出来る．

.. code-block:: fortran

      integer :: i, j
      integer :: lb(2), ub(2)
      integer, pointer :: rptr(:,:)
      integer, target :: x(9,9)

      do j = 1, 9
         do i = 1, 9
            x(i,j) = i + (j-1)*9
         end do
      end do

      ! 部分配列へ結合
      rptr => x(2:4,2:6)

      lb = lbound(rptr) ! (/1, 1/)
      ub = ubound(rptr) ! (/3, 5/)

      do j = lb(2), ub(2)
         do i = lb(1), ub(1)
            write(*, fmt='(i7)', advance='no') rptr(i,j)
         end do
         write(*,*)
      end do

上の例では13行目において ``rptr`` を ``x`` の部分配列と結合させている．ポインタ変数の場合と同様に，``rptr`` は ``x`` への別名となり，このポインタ配列に対するアクセスは ``x`` の対応する要素へのアクセスと等しくなる．

またポインタ配列に対しても ``allocate`` による無名領域への結合が出来るので，動的配列と同様に用いることも可能である [#]_．

.. _appendix_data_structure:

データ構造
----------

これまでの例では，ポインタは複雑な割にはありがたみが少ない．実際にポインタを使う必要性は特に感じられないだろう．ポインタが特に重要となってくるのは柔軟なデータ構造を扱う場合である．実は配列もデータ構造の一つである．配列はサイズが固定で，全ての要素が同じ型のデータの集まりなので比較的簡単に扱うことが出来る．すなわち，配列の各要素はメモリ上に連続的に配置されているので，任意の要素への直接アクセス(ランダムアクセス)が可能という長所を持つ(任意の要素のアドレスが簡単に計算出来る)．
その一方で，要素をある特定の位置に挿入したい場合にはそれ以降の要素を全てずらさなければならないし，サイズの変更が簡単には出来ないという短所がある．

.. figure:: figure/list.png
   :align: center
   :width: 480px
   :alt: List構造．

   List構造．

配列とよく対比されるデータ構造として，リスト(list)が知られている．図に示すようにリスト構造は各要素が他の要素へのポインタ(アドレス)を保持する．従って，リスト構造では任意の要素(例えば先頭から :math:`N` 番目の要素)へのアクセスをしようと思ってもそのアドレスが分からない．すなわち，常に各要素に対して順番にアクセス(シーケンシャルアクセス)をしなければならない．これは配列に対するリスト構造の短所である．その一方で，任意の場所への要素の挿入や削除をするにはポインタアドレスの付け替えをするだけで実現出来る．また，リストの末尾に要素を追加するには新しい要素を生成( ``allocate``)して，その要素に対するポインタを指定してやれば良い．このような特徴があるため，シーケンシャルアクセスしか必要とされない代わりに，頻繁にサイズ変更，要素の挿入・削除があるような用途にはリストが有用となる．

例として，各要素の値が整数であるリストは以下のように構造型を用いて定義することになる．

.. code-block:: fortran

      type :: list_type
         type(list_type), pointer :: next
         integer :: value
      end type list_type

リストの実装( ``list.f90`` )は少し長くなるのでここには掲載しないが，地道にポインタを使ってアドレスを付け替えたりするだけである．以下の例は ``list.f90`` で実装したモジュール ``mod_list`` の使い方を示している．リストの伸長は ``append``，要素の挿入は ``insert``，削除は ``remove`` を用いてなどのモジュール内部手続きによって行うことが出来る．なお10行目ではモジュール内で定義した代入演算子を用いてリストを配列によって初期化している．

.. code-block:: fortran

    program sample
      use mod_list
      implicit none

      type(list_type), pointer :: a

      nullify(a)

      write(*, fmt='(a20)', advance='no') 'initialize : '
      a = 1
      call show(a)

      write(*, fmt='(a20)', advance='no') 'append 2 : '
      call append(a, 2)
      call show(a)

      write(*, fmt='(a20)', advance='no') 'append 3 : '
      call append(a, 3)
      call show(a)

      write(*, fmt='(a20)', advance='no') 'insert -1 at 1 : '
      call insert(a, 1, -1)
      call show(a)

      write(*, fmt='(a20)', advance='no') 'insert -2 at 3 : '
      call insert(a, 3, -2)
      call show(a)

      write(*, fmt='(a20)', advance='no') 'remove at 1 : '
      call remove(a, 1)
      call show(a)

      write(*, fmt='(a20)', advance='no') 'remove at 3 : '
      call remove(a, 3)
      call show(a)

      write(*, fmt='(a20)', advance='no') 'delete : '
      call delete(a)
      call show(a)

    end program sample

このプログラムの実行結果は以下のようになる．正しくリストの操作が出来ていることが分かるかと思う．

.. code-block:: bash

      $ ./a.out
           initialize : List = [    1 ]
             append 2 : List = [    1     2 ]
             append 3 : List = [    1     2     3 ]
       insert -1 at 1 : List = [   -1     1     2     3 ]
       insert -2 at 3 : List = [   -1     1    -2     2     3 ]
          remove at 1 : List = [    1    -2     2     3 ]
          remove at 3 : List = [    1    -2     3 ]
               delete : List = []

ここではリストの実装例を見たが，他にもキュー(queue)やスタック(stack)，ツリー(tree)，ハッシュ(hash)などがよく用いられるデータ構造の例として挙げられる．(これらはあくまでも大まかな分類であり，それぞれに対して更に細かい種類がある．例えば単にリストと言っても，片方向リストや双方向リスト，線形リストや循環リストなどの種類が存在する．)

ただし，大規模な数値計算においてこのようなデータ構造が用いられることはあまり多くない．なぜなら一般に柔軟なデータ構造を用いる処理は単純な配列に比べて効率が悪いためである．大規模数値シミュレーションではパフォーマンスが非常に重要となってくるため，複雑なデータ構造は極力使わずに実装される．しかし，配列では実装しづらい複雑なアルゴリズムを用いる必要がある場合にはデータ構造の知識も重要になってくるかもしれないので，興味のある人は勉強してみて欲しい．なおC++を始めとする多くの言語において，**データ構造を扱う標準ライブラリ** (組込み関数のようなもの)が存在している．従って，複雑なデータ構造の扱いが必要な場合には大人しくFortranを使うのは諦めて，他の言語を用いることを推奨する．パフォーマンスが必要な場合にはC++など，そうでないならPythonなどを使うことで開発効率が格段に向上するであろう．

デバッグのテクニック :sup:`†`
==============================

プリプロセッサ
--------------

プログラムの開発中(デバッグ中)には一時的にソースコードの一部分をコメントアウトしてその影響を調べたいことが多々あるかと思う．このような時にプリプロセッサと呼ばれる機能を用いると便利である．プリプロセッサとはC/C++のコンパイラが自動的に行う前処理のことであるが，Fortranコンパイラでも多くの場合オプションによってプリプロセッサを有効にすることが出来る．なお，プリプロセッサを使うにはgfortranであれば ``-cpp`` オプション [#]_ を付けてコンパイルすれば良い．または拡張子を ``.f90`` では無く ``.F90`` とすればオプションを指定しなくても自動的にプリプロセッサが有効になる．

プリプロセッサの機能は様々であるが，特に簡単で便利なのは以下の様な使い方である．

::

    #if 0
      ここはコンパイラに無視されるので何が書いてあっても良い
    #endif

一時的に実行させたく無い処理については，上の例のように ``#if 0`` から ``#endif`` によって囲むことでコンパイラにその部分を無視させることが出来る．コンパイラに認識させたい時には ``0`` を ``1`` に変更するだけで良いので，特定の処理が結果に与える影響を簡単に調べることが出来る．さらに

.. code-block:: c

    #if 1
      処理A
    #else
      処理B
    #endif

としておけば，``1`` の時には処理A，``0`` の時には処理Bをそれぞれコンパイルさせる事が出来る．

プリプロセッサは基本的にC言語で用いられるものと同じなので，**マクロ** という機能も用いることが出来る．例えば

.. code-block:: c

    #ifdef _DEBUG
      デバッグ処理
    #endif

となっている場合に

.. code-block:: bash

     $ gfortran -cpp -D_DEBUG sample.f90

とすれば"デバッグ処理"がコンパイルされる．ここで ``-D_DEBUG`` は ``_DEBUG`` というマクロを定義するという意味である．マクロを用いたプリプロセッサには様々な機能があり，より複雑な指定も可能である．

.. code-block:: c

    #if   _DEBUG_MODE == 0
      デバッグモード0
    #elif _DEBUG_MODE == 1
      デバッグモード1
    #elif _DEBUG_MODE == 2
      デバッグモード2
    #endif

のような場合には，``_DEBUG_MODE`` という名前のマクロの値 [#]_ によってコンパイルする処理を切り替えることが出来る．マクロの値もコマンドラインから明示的に与えることが出来る．例えば

.. code-block:: bash

     $ gfortran -cpp -D_DEBUG_MODE=1 sample.f90

のように実行すれば，マクロ ``_DEBUG_MODE`` の値が1に定義され，"デバッグモード1"の処理がコンパイルされる．

printfデバッグ
--------------

デバッグの基本中の基本テクニックは ``printf`` デバッグと呼ばれる．``printf`` とはC言語で標準出力に表示するための関数名で，要するに間違っていそうな箇所に当たりをつけて，途中結果を出力して確認するという古典的な手法である．Fortranの場合にはひたすら ``write(*,*)`` で怪しい変数を出力してみれば大抵の場合(すくなくとも演習の課題レベルの場合)には自ずとバグの原因が見えてくる [#]_．

このデバッグ手法はプリプロセッサと組み合わせると便利である．例えば

.. code-block:: fortran

    #ifdef _DEBUG
    #define DEBUG_PRINT(a) write(*,*) (a)
    #else
    #define DEBUG_PRINT(a)
    #endif

としておくと，任意の場所で

.. code-block:: c

      DEBUG_PRINT(出力したい変数)

のように ``DEBUG_PRINT`` というマクロを関数(サブルーチン)のように用いることが出来る．この時，コンパイル時にオプション ``-D_DEBUG`` を付けると ``DEBUG_PRINT`` の引数に与えた変数の値が出力されるが，``-D_DEBUG`` を付けなければ何も出力されない．つまり，この形式でデバッグメッセージを埋め込んでおけば，ソースコードを一切修正することなく，コマンドラインのみでデバッグモードに切り替えることが出来る．
(これは ``_DEBUG`` というマクロが定義されている場合には，``DEBUG_PRINT(x)`` が ``write(*,*) (x)`` に変換され，それ以外の場合は単なるホワイトスペース(空白)に変換されるためである．)

このようなテクニックは非常に有用で，開発効率を大幅に高めてくれるハズなので，少しずつ身につけていくと良い．

gdb
---

To be written.

C言語とのリンク :sup:`†`
=========================

To be written.

Fortran 77について :sup:`†`
============================

To be written.

..
.. 課題
..

.. include:: kadai/chap10_kadai.rst

----


.. [#]
   これはFortranの規格というわけではないようだが，多くのコンパイラがこのような仕様になっている．

.. [#]
   C言語のインクルードパスの指定と同じである．

.. [#]
   単に ``time`` とするとシェルの組込みコマンドになってしまうので，``/usr/bin/time`` と絶対パスを指定している．シェル組込みの ``time`` でも問題は無いが，出力が多少異なるであろう．

.. [#]
   C言語のポインタと異なり，``=>`` でポインタのアドレスを指定する以外は普通の変数のように使える．これによってポインタであることを意識せずに用いることが出来る．個人的には逆に分かりにくいように思うのだが．

.. [#]
   ただしポインタ配列の場合は ``allocatable`` とは異なり，スコープから外れた場合に自動で ``deallocate`` されないようである．

.. [#]
   ifortでは ``-fpp``．

.. [#]
   変数のように見えるが，プリプロセッサで(コンパイルされる前に)処理されるのでプログラム中の変数にはなっていない．

.. [#]
   演習中にディスプレイの前でフリーズしている人を良く見かけるが，考えているだけでは何も進まない．とりあえずヒントを探すという意味で値を出力するのは非常に重要である．
